<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MicroVibe - ä¸»æ’­æ¨æµ (SFU æ¨¡å¼)</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }

    .container {
      background: white;
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      max-width: 900px;
      width: 100%;
      overflow: hidden;
    }

    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 30px;
      text-align: center;
    }

    .header h1 {
      font-size: 28px;
      margin-bottom: 10px;
    }

    .header p {
      font-size: 14px;
      opacity: 0.9;
    }

    .content {
      padding: 30px;
    }

    .video-container {
      position: relative;
      background: #000;
      border-radius: 10px;
      overflow: hidden;
      margin-bottom: 20px;
    }

    video {
      width: 100%;
      height: auto;
      display: block;
    }

    .video-overlay {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
    }

    .status-badge {
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #10b981;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .stats {
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 12px;
      border-radius: 10px;
      font-size: 11px;
      line-height: 1.6;
    }

    .form-group {
      margin-bottom: 20px;
    }

    .form-group label {
      display: block;
      margin-bottom: 8px;
      font-weight: 600;
      color: #374151;
    }

    .form-group input,
    .form-group select {
      width: 100%;
      padding: 12px;
      border: 2px solid #e5e7eb;
      border-radius: 8px;
      font-size: 14px;
      transition: border-color 0.3s;
    }

    .form-group input:focus,
    .form-group select:focus {
      outline: none;
      border-color: #667eea;
    }

    .button-group {
      display: flex;
      gap: 10px;
      margin-top: 20px;
    }

    button {
      flex: 1;
      padding: 14px 24px;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
    }

    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .btn-primary:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
    }

    .btn-secondary {
      background: #6b7280;
      color: white;
    }

    .btn-danger {
      background: #ef4444;
      color: white;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .log-container {
      background: #f9fafb;
      border: 2px solid #e5e7eb;
      border-radius: 8px;
      padding: 15px;
      max-height: 200px;
      overflow-y: auto;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      margin-top: 20px;
    }

    .log-entry {
      padding: 4px 0;
      border-bottom: 1px solid #e5e7eb;
    }

    .log-entry:last-child {
      border-bottom: none;
    }

    .log-time {
      color: #6b7280;
      margin-right: 8px;
    }

    .log-info { color: #3b82f6; }
    .log-success { color: #10b981; }
    .log-error { color: #ef4444; }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>ğŸ–¥ï¸ å±å¹•å½•åˆ¶æ¨æµæµ‹è¯•</h1>
      <p>MicroVibe WebRTC SFU ç›´æ’­ç³»ç»Ÿ - å±å¹•å…±äº«æ¨¡å¼</p>
    </div>

    <div class="content">
      <!-- è§†é¢‘é¢„è§ˆ -->
      <div class="video-container">
        <video id="localVideo" autoplay muted playsinline></video>
        <div class="video-overlay">
          <div class="status-badge" id="statusBadge">
            <span class="status-dot"></span>
            <span id="statusText">æœªè¿æ¥</span>
          </div>
          <div class="stats" id="stats" style="display: none;">
            <div>è§†é¢‘ç ç‡: <span id="videoBitrate">0</span> kbps</div>
            <div>éŸ³é¢‘ç ç‡: <span id="audioBitrate">0</span> kbps</div>
            <div>ä¸¢åŒ…ç‡: <span id="packetLoss">0</span>%</div>
            <div>å»¶è¿Ÿ: <span id="rtt">0</span> ms</div>
          </div>
        </div>
      </div>

      <!-- é…ç½®è¡¨å• -->
      <div class="form-group">
        <label for="apiUrl">API åœ°å€</label>
        <input type="text" id="apiUrl" value="/api/v1" placeholder="/api/v1">
      </div>

      <div class="form-group">
        <label for="roomTitle">ç›´æ’­é—´æ ‡é¢˜</label>
        <input type="text" id="roomTitle" value="å±å¹•å½•åˆ¶æµ‹è¯•" placeholder="è¾“å…¥ç›´æ’­é—´æ ‡é¢˜">
      </div>

      <div class="form-group">
        <label for="categoryId">ç›´æ’­åˆ†ç±»</label>
        <select id="categoryId">
          <option value="1" selected>æ¸¸æˆ</option>
          <option value="2">å¨±ä¹</option>
          <option value="3">æ•™è‚²</option>
          <option value="4">ç§‘æŠ€</option>
          <option value="5">ç”Ÿæ´»</option>
          <option value="6">å…¶ä»–</option>
        </select>
      </div>

      <div class="form-group">
        <label for="videoCodec">è§†é¢‘ç¼–è§£ç å™¨</label>
        <select id="videoCodec">
          <option value="VP8">VP8 (å…¼å®¹æ€§å¥½)</option>
          <option value="VP9">VP9 (é«˜å‹ç¼©ç‡)</option>
          <option value="H264" selected>H264 (ç¡¬ä»¶åŠ é€Ÿ)</option>
        </select>
      </div>

      <div class="form-group">
        <label for="resolution">è§†é¢‘åˆ†è¾¨ç‡</label>
        <select id="resolution">
          <option value="640x480">480p (640x480)</option>
          <option value="1280x720" selected>720p (1280x720)</option>
          <option value="1920x1080">1080p (1920x1080)</option>
        </select>
      </div>

      <!-- æŒ‰é’®ç»„ -->
      <div class="button-group">
        <button id="startBtn" class="btn-primary" onclick="startBroadcast()">ğŸ–¥ï¸ å¼€å§‹å±å¹•å½•åˆ¶</button>
        <button id="stopBtn" class="btn-danger" onclick="stopBroadcast()" disabled>â¹ï¸ åœæ­¢å½•åˆ¶</button>
      </div>

      <!-- æ—¥å¿— -->
      <div class="log-container" id="logContainer">
        <div class="log-entry">
          <span class="log-time">[ç³»ç»Ÿ]</span>
          <span class="log-info">å‡†å¤‡å°±ç»ªï¼Œç‚¹å‡»"å¼€å§‹å±å¹•å½•åˆ¶"é€‰æ‹©è¦å…±äº«çš„å±å¹•...</span>
        </div>
      </div>
    </div>
  </div>

  <script>
    // å…¨å±€å˜é‡
    let localStream = null;
    let peerConnection = null;
    let websocket = null;
    let roomId = null;
    let streamKey = null; // âœ… æ–°å¢ï¼šä¿å­˜æ¨æµå¯†é’¥
    let sessionId = null;
    let statsInterval = null;
    let lastStats = { video: {}, audio: {} }; // âœ… æ–°å¢ï¼šè®°å½•ä¸Šæ¬¡ç»Ÿè®¡æ•°æ®
    const token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxLCJ1c2VybmFtZSI6ImFrYWRtaW4iLCJpc3MiOiJtaWNyb3ZpYmUtZ28iLCJleHAiOjE3NjIyNDg4ODEsIm5iZiI6MTc2MjE2MjQ4MSwiaWF0IjoxNzYyMTYyNDgxfQ.gJCeHcGkS3s1nuQHcxSVdoDUqW6TfGLbeFr8UOxO_Ig'; // å·²æ›´æ–°ä¸º testuser çš„æœ‰æ•ˆ token (è¿‡æœŸæ—¶é—´: 2025-11-04)

    // æ—¥å¿—å‡½æ•°
    function log(message, type = 'info') {
      const logContainer = document.getElementById('logContainer');
      const time = new Date().toLocaleTimeString();
      const entry = document.createElement('div');
      entry.className = 'log-entry';
      entry.innerHTML = `
        <span class="log-time">[${time}]</span>
        <span class="log-${type}">${message}</span>
      `;
      logContainer.appendChild(entry);
      logContainer.scrollTop = logContainer.scrollHeight;
      console.log(`[${type}] ${message}`);
    }

    // æ›´æ–°çŠ¶æ€
    function updateStatus(text, color = '#10b981') {
      document.getElementById('statusText').textContent = text;
      document.querySelector('.status-dot').style.background = color;
    }

    // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
    function updateStats(stats) {
      document.getElementById('videoBitrate').textContent = Math.round(stats.videoBitrate / 1000);
      document.getElementById('audioBitrate').textContent = Math.round(stats.audioBitrate / 1000);
      document.getElementById('packetLoss').textContent = (stats.packetLoss * 100).toFixed(2);
      document.getElementById('rtt').textContent = Math.round(stats.rtt * 1000);
    }

    // å¼€å§‹ç»Ÿè®¡ä¿¡æ¯æ”¶é›†
    function startStatsCollection() {
      if (statsInterval) clearInterval(statsInterval);

      statsInterval = setInterval(async () => {
        if (!peerConnection) return;

        const stats = await peerConnection.getStats();
        let videoBitrate = 0;
        let audioBitrate = 0;
        let packetLoss = 0;
        let rtt = 0;

        stats.forEach(report => {
          if (report.type === 'outbound-rtp') {
            const kind = report.kind;
            const now = report.timestamp;
            const bytes = report.bytesSent;

            // è®¡ç®—ç ç‡ = (å½“å‰å­—èŠ‚æ•° - ä¸Šæ¬¡å­—èŠ‚æ•°) * 8 / (æ—¶é—´å·®/1000) / 1000 (è½¬kbps)
            if (lastStats[kind].bytesSent && lastStats[kind].timestamp) {
              const bytesDiff = bytes - lastStats[kind].bytesSent;
              const timeDiff = (now - lastStats[kind].timestamp) / 1000; // è½¬ä¸ºç§’
              const bitrate = (bytesDiff * 8) / timeDiff / 1000; // kbps

              if (kind === 'video') {
                videoBitrate = bitrate;
              } else if (kind === 'audio') {
                audioBitrate = bitrate;
              }
            }

            // ä¿å­˜å½“å‰ç»Ÿè®¡æ•°æ®ä¾›ä¸‹æ¬¡è®¡ç®—
            lastStats[kind] = { bytesSent: bytes, timestamp: now };
          }
          if (report.type === 'candidate-pair' && report.state === 'succeeded') {
            rtt = report.currentRoundTripTime || 0;
            packetLoss = report.packetsLost / (report.packetsSent || 1);
          }
        });

        updateStats({ videoBitrate, audioBitrate, packetLoss, rtt });
      }, 2000);
    }

    // å¼€å§‹ç›´æ’­
    async function startBroadcast() {
      try {
        log('æ­£åœ¨åˆå§‹åŒ–...', 'info');
        document.getElementById('startBtn').disabled = true;

        // 1. è·å–å±å¹•å½•åˆ¶æµ
        log('æ­£åœ¨è¯·æ±‚å±å¹•å½•åˆ¶æƒé™...', 'info');

        // æ£€æŸ¥æµè§ˆå™¨æ˜¯å¦æ”¯æŒå±å¹•å½•åˆ¶
        if (!navigator.mediaDevices.getDisplayMedia) {
          throw new Error('å½“å‰æµè§ˆå™¨ä¸æ”¯æŒå±å¹•å½•åˆ¶åŠŸèƒ½ï¼Œè¯·ä½¿ç”¨ Chrome/Edge/Firefox æœ€æ–°ç‰ˆæœ¬');
        }

        // è·å–å±å¹•å½•åˆ¶æµ
        const resolution = document.getElementById('resolution').value.split('x');
        try {
          // è·å–å±å¹•è§†é¢‘æµ
          const displayStream = await navigator.mediaDevices.getDisplayMedia({
            video: {
              width: { ideal: parseInt(resolution[0]) },
              height: { ideal: parseInt(resolution[1]) },
              frameRate: { ideal: 30 }
            },
            audio: {
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true
            }
          });

          // è·å–ç³»ç»ŸéŸ³é¢‘ï¼ˆå¦‚æœç”¨æˆ·é€‰æ‹©äº†å…±äº«éŸ³é¢‘ï¼‰
          const audioTracks = displayStream.getAudioTracks();

          if (audioTracks.length > 0) {
            log('âœ… æ£€æµ‹åˆ°ç³»ç»ŸéŸ³é¢‘æµ', 'success');
            localStream = displayStream;
          } else {
            // å¦‚æœæ²¡æœ‰ç³»ç»ŸéŸ³é¢‘ï¼Œå°è¯•è·å–éº¦å…‹é£éŸ³é¢‘ä½œä¸ºè¡¥å……
            log('æœªæ£€æµ‹åˆ°ç³»ç»ŸéŸ³é¢‘ï¼Œå°è¯•è·å–éº¦å…‹é£éŸ³é¢‘...', 'info');
            try {
              const audioStream = await navigator.mediaDevices.getUserMedia({
                audio: {
                  echoCancellation: true,
                  noiseSuppression: true,
                  autoGainControl: true
                },
              });

              // åˆå¹¶è§†é¢‘æµå’ŒéŸ³é¢‘æµ
              const videoTrack = displayStream.getVideoTracks()[0];
              const audioTrack = audioStream.getAudioTracks()[0];
              localStream = new MediaStream([videoTrack, audioTrack]);
              log('âœ… å·²æ·»åŠ éº¦å…‹é£éŸ³é¢‘', 'success');
            } catch (audioErr) {
              log('éº¦å…‹é£éŸ³é¢‘è·å–å¤±è´¥ï¼Œä»…ä½¿ç”¨å±å¹•è§†é¢‘æµ', 'info');
              localStream = displayStream;
            }
          }

          // ç›‘å¬ç”¨æˆ·åœæ­¢å±å¹•å…±äº«
          displayStream.getVideoTracks()[0].onended = () => {
            log('ç”¨æˆ·åœæ­¢äº†å±å¹•å…±äº«', 'info');
            stopBroadcast();
          };

        } catch (err) {
          if (err.name === 'NotAllowedError') {
            throw new Error('ç”¨æˆ·æ‹’ç»äº†å±å¹•å½•åˆ¶æƒé™');
          } else if (err.name === 'NotFoundError') {
            throw new Error('æœªæ‰¾åˆ°å¯ç”¨çš„å±å¹•å½•åˆ¶æº');
          } else {
            throw err;
          }
        }

        document.getElementById('localVideo').srcObject = localStream;

        // æ˜¾ç¤ºæµä¿¡æ¯
        const videoTrack = localStream.getVideoTracks()[0];
        const audioTrack = localStream.getAudioTracks()[0];
        log(`âœ… å±å¹•å½•åˆ¶æµè·å–æˆåŠŸ`, 'success');
        log(`è§†é¢‘è½¨é“: ${videoTrack ? videoTrack.label : 'æ— '}`, 'info');
        log(`éŸ³é¢‘è½¨é“: ${audioTrack ? audioTrack.label : 'æ— '}`, 'info');

        // 2. åˆ›å»ºç›´æ’­é—´
        log('æ­£åœ¨åˆ›å»ºç›´æ’­é—´...', 'info');
        const apiUrl = document.getElementById('apiUrl').value;
        const categoryId = parseInt(document.getElementById('categoryId').value);
        const createResponse = await fetch(`${apiUrl}/live/create`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            title: document.getElementById('roomTitle').value,
            description: 'å±å¹•å½•åˆ¶æ¨æµæµ‹è¯• - Pion Ion SFU',
            category_id: categoryId
          })
        });

        if (!createResponse.ok) {
          throw new Error('åˆ›å»ºç›´æ’­é—´å¤±è´¥');
        }

        const createData = await createResponse.json();
        roomId = createData.data.room_id;
        streamKey = createData.data.stream_key; // âœ… ä¿å­˜æ¨æµå¯†é’¥
        sessionId = `${roomId}-${Date.now()}`;
        const categoryName = document.getElementById('categoryId').selectedOptions[0].text;
        log(`âœ… ç›´æ’­é—´åˆ›å»ºæˆåŠŸ: ${roomId}`, 'success');
        log(`æ¨æµå¯†é’¥: ${streamKey}`, 'info');
        log(`åˆ†ç±»: ${categoryName} (ID: ${categoryId})`, 'info');

        // 3. è¿æ¥ WebSocket ä¿¡ä»¤æœåŠ¡å™¨
        log('æ­£åœ¨è¿æ¥ä¿¡ä»¤æœåŠ¡å™¨...', 'info');
        const wsUrl = apiUrl.replace('http', 'ws') + `/live/ws?room_id=${roomId}&user_id=1&username=broadcaster&role=publisher`;
        websocket = new WebSocket(wsUrl);

        websocket.onopen = () => {
          log('âœ… WebSocket è¿æ¥æˆåŠŸ', 'success');
          setupPeerConnection();
        };

        websocket.onmessage = handleSignalingMessage;
        websocket.onerror = (error) => {
          log(`âŒ WebSocket é”™è¯¯: ${error}`, 'error');
        };
        websocket.onclose = () => {
          log('WebSocket è¿æ¥å…³é—­', 'info');
        };

      } catch (error) {
        let errorMsg = error.message;

        // æä¾›æ›´å‹å¥½çš„é”™è¯¯ä¿¡æ¯
        if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
          errorMsg = 'ç”¨æˆ·æ‹’ç»äº†å±å¹•å½•åˆ¶æƒé™';
        } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
          errorMsg = 'æœªæ‰¾åˆ°å¯ç”¨çš„å±å¹•å½•åˆ¶æº';
        } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
          errorMsg = 'æ— æ³•è®¿é—®å±å¹•å½•åˆ¶ï¼Œå¯èƒ½è¢«å…¶ä»–ç¨‹åºå ç”¨';
        } else if (error.name === 'OverconstrainedError' || error.name === 'ConstraintNotSatisfiedError') {
          errorMsg = 'å±å¹•ä¸æ”¯æŒè¯·æ±‚çš„åˆ†è¾¨ç‡æˆ–é…ç½®ï¼Œè¯·å°è¯•å…¶ä»–è®¾ç½®';
        } else if (error.name === 'NotSupportedError') {
          errorMsg = 'å½“å‰æµè§ˆå™¨ä¸æ”¯æŒå±å¹•å½•åˆ¶ï¼Œè¯·ä½¿ç”¨ Chrome/Edge/Firefox æœ€æ–°ç‰ˆæœ¬';
        }

        log(`âŒ é”™è¯¯: ${errorMsg}`, 'error');
        console.error('è¯¦ç»†é”™è¯¯:', error);
        document.getElementById('startBtn').disabled = false;
        stopBroadcast();
      }
    }

    // è®¾ç½® PeerConnection
    async function setupPeerConnection() {
      try {
        log('æ­£åœ¨åˆ›å»º PeerConnection...', 'info');

        // åˆ›å»º PeerConnection
        // æœ¬åœ°æµ‹è¯•ä¸éœ€è¦ STUNï¼ŒSFU ä½¿ç”¨ ICE Lite æ¨¡å¼
        peerConnection = new RTCPeerConnection({
          iceServers: []
        });

        // æ·»åŠ æœ¬åœ°åª’ä½“æµ
        localStream.getTracks().forEach(track => {
          peerConnection.addTrack(track, localStream);
          log(`æ·»åŠ  ${track.kind} è½¨é“`, 'info');
        });

        // ICE Candidate å¤„ç†
        peerConnection.onicecandidate = (event) => {
          if (event.candidate) {
            websocket.send(JSON.stringify({
              type: 'ice',
              room_id: roomId,
              payload: event.candidate
            }));
          }
        };

        // è¿æ¥çŠ¶æ€ç›‘å¬
        peerConnection.onconnectionstatechange = () => {
          const state = peerConnection.connectionState;
          log(`è¿æ¥çŠ¶æ€: ${state}`, 'info');

          if (state === 'connected') {
            updateStatus('ğŸ”´ ç›´æ’­ä¸­', '#ef4444');
            document.getElementById('stats').style.display = 'block';
            startStatsCollection();
            startLive();
          } else if (state === 'failed' || state === 'disconnected') {
            updateStatus('è¿æ¥å¤±è´¥', '#ef4444');
            log('âŒ è¿æ¥å¤±è´¥', 'error');
          }
        };
          const videoCodec = document.getElementById('videoCodec').value;
          let codecConstraints = [];

// æ ¹æ®é€‰æ‹©çš„ç¼–ç ç”Ÿæˆçº¦æŸï¼ˆå¯¹åº” RTP  payload typeï¼Œå‚è€ƒ RFC æ ‡å‡†ï¼‰
          switch (videoCodec) {
              case 'VP8':
                  codecConstraints = [{ type: 'video', sdpFmtpLine: 'vp8' }];
                  break;
              case 'VP9':
                  codecConstraints = [{ type: 'video', sdpFmtpLine: 'vp9' }];
                  break;
              case 'H264':
                  // H264 éœ€æŒ‡å®šå…·ä½“æ ¼å¼ï¼ˆé¿å…ä¸ SFU ç¼–ç åå•†ä¸åŒ¹é…ï¼‰
                  codecConstraints = [{ type: 'video', sdpFmtpLine: 'h264 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01f' }];
                  break;
          }


          const offerOptions = {
              offerToReceiveAudio: false,  // ä¸»æ’­ç«¯ä¸æ¥æ”¶éŸ³é¢‘ï¼ˆåªå‘é€ï¼‰
              offerToReceiveVideo: false,  // ä¸»æ’­ç«¯ä¸æ¥æ”¶è§†é¢‘ï¼ˆåªå‘é€ï¼‰
              voiceActivityDetection: false,
              videoCodecPreferences: codecConstraints  // åº”ç”¨ç¼–ç çº¦æŸ
          };

        // åˆ›å»º Offerï¼ˆä¸»æ’­ç«¯åªå‘é€ï¼Œä¸æ¥æ”¶ï¼‰
        log('æ­£åœ¨åˆ›å»º SDP Offer...', 'info');
        const offer = await peerConnection.createOffer(offerOptions);

        await peerConnection.setLocalDescription(offer);

        // å‘é€ Offer åˆ°ä¿¡ä»¤æœåŠ¡å™¨
        websocket.send(JSON.stringify({
          type: 'offer',
          room_id: roomId,
          payload: offer.sdp  // âœ… ç›´æ¥å‘é€ SDP å­—ç¬¦ä¸²
        }));

        log('âœ… Offer å·²å‘é€', 'success');

      } catch (error) {
        log(`âŒ PeerConnection é”™è¯¯: ${error.message}`, 'error');
      }
    }

    // å¤„ç†ä¿¡ä»¤æ¶ˆæ¯
    async function handleSignalingMessage(event) {
      const message = JSON.parse(event.data);

      switch (message.type) {
        case 'answer':
          log('æ”¶åˆ° SDP Answer', 'info');
          // payload å¯èƒ½æ˜¯å­—ç¬¦ä¸²æˆ–å¯¹è±¡ï¼Œéœ€è¦è§„èŒƒåŒ–
          let answerSdp = message.payload;
          if (typeof answerSdp === 'string') {
            answerSdp = { type: 'answer', sdp: answerSdp };
          }
          const answer = new RTCSessionDescription(answerSdp);
          await peerConnection.setRemoteDescription(answer);
          log('âœ… SDP Answer å·²è®¾ç½®', 'success');
          break;

        case 'ice':
          log('æ”¶åˆ° ICE Candidate', 'info');
          try {
            // ä¿®å¤æ–¹æ³•åæ‹¼å†™é”™è¯¯ï¼šaddICECandidate -> addIceCandidate
            await peerConnection.addIceCandidate(new RTCIceCandidate(message.payload));
          } catch (err) {
            log(`âš ï¸ æ·»åŠ  ICE Candidate å¤±è´¥: ${err.message}`, 'warn');
          }
          break;

        case 'error':
          log(`âŒ æœåŠ¡å™¨é”™è¯¯: ${message.payload.error}`, 'error');
          break;

        default:
          log(`æ”¶åˆ°æœªçŸ¥æ¶ˆæ¯ç±»å‹: ${message.type}`, 'info');
      }
    }

    // å¼€å§‹ç›´æ’­ï¼ˆæ›´æ–°çŠ¶æ€ï¼‰
    async function startLive() {
      try {
        const apiUrl = document.getElementById('apiUrl').value;
        const response = await fetch(`${apiUrl}/live/start`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ stream_key: streamKey }) // âœ… ä½¿ç”¨ stream_key
        });

        if (response.ok) {
          log('âœ… ç›´æ’­å·²å¼€å§‹ï¼Œè§‚ä¼—å¯ä»¥è§‚çœ‹', 'success');
          document.getElementById('stopBtn').disabled = false;
        } else {
          const errorData = await response.json();
          log(`âŒ å¯åŠ¨ç›´æ’­å¤±è´¥: ${errorData.message || 'æœªçŸ¥é”™è¯¯'}`, 'error');
        }
      } catch (error) {
        log(`âŒ å¯åŠ¨ç›´æ’­å¤±è´¥: ${error.message}`, 'error');
      }
    }

    // åœæ­¢ç›´æ’­
    async function stopBroadcast() {
      log('æ­£åœ¨åœæ­¢ç›´æ’­...', 'info');

      // åœæ­¢ç»Ÿè®¡
      if (statsInterval) {
        clearInterval(statsInterval);
        statsInterval = null;
      }

      // å…³é—­ PeerConnection
      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
        log('PeerConnection å·²å…³é—­', 'info');
      }

      // å…³é—­ WebSocket
      if (websocket) {
        websocket.close();
        websocket = null;
        log('WebSocket å·²å…³é—­', 'info');
      }

      // åœæ­¢æœ¬åœ°åª’ä½“æµ
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
        document.getElementById('localVideo').srcObject = null;
        log('æœ¬åœ°åª’ä½“æµå·²åœæ­¢', 'info');
      }

      // ç»“æŸç›´æ’­
      if (streamKey) {
        try {
          const apiUrl = document.getElementById('apiUrl').value;
          await fetch(`${apiUrl}/live/end`, {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${token}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ stream_key: streamKey }) // âœ… ä½¿ç”¨ stream_key
          });
          log('âœ… ç›´æ’­å·²ç»“æŸ', 'success');
        } catch (error) {
          log(`ç»“æŸç›´æ’­å¤±è´¥: ${error.message}`, 'error');
        }
      }

      // é‡ç½®çŠ¶æ€
      updateStatus('æœªè¿æ¥', '#6b7280');
      document.getElementById('stats').style.display = 'none';
      document.getElementById('startBtn').disabled = false;
      document.getElementById('stopBtn').disabled = true;
      roomId = null;
      streamKey = null; // âœ… é‡ç½® stream_key
      sessionId = null;

      log('âœ… ç›´æ’­å·²åœæ­¢', 'success');
    }

    // é¡µé¢å…³é—­æ—¶æ¸…ç†
    window.addEventListener('beforeunload', stopBroadcast);
  </script>
</body>
</html>
