<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MicroVibe - è§‚ä¼—è§‚çœ‹ (SFU ä¿¡ä»¤ä¸­ç»§æ¨¡å¼)</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }

    .container {
      background: white;
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      max-width: 1200px;
      width: 100%;
      overflow: hidden;
    }

    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 30px;
      text-align: center;
    }

    .header h1 {
      font-size: 28px;
      margin-bottom: 10px;
    }

    .header p {
      font-size: 14px;
      opacity: 0.9;
    }

    .content {
      padding: 30px;
    }

    .video-container {
      position: relative;
      background: #000;
      border-radius: 10px;
      overflow: hidden;
      margin-bottom: 20px;
    }

    video {
      width: 100%;
      height: auto;
      display: block;
      min-height: 400px;
    }

    .video-overlay {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
    }

    .status-badge {
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #ef4444;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .status-dot.connected {
      background: #10b981;
    }

    .viewer-count {
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .stats {
      position: absolute;
      bottom: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 12px;
      border-radius: 10px;
      font-size: 11px;
      line-height: 1.6;
    }

    .room-list {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }

    .room-card {
      background: #f9fafb;
      border: 2px solid #e5e7eb;
      border-radius: 10px;
      padding: 15px;
      cursor: pointer;
      transition: all 0.3s;
    }

    .room-card:hover {
      border-color: #667eea;
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
    }

    .room-card.active {
      border-color: #764ba2;
      background: #f5f3ff;
    }

    .room-title {
      font-weight: 600;
      margin-bottom: 5px;
      color: #1f2937;
    }

    .room-info {
      font-size: 12px;
      color: #6b7280;
    }

    .form-group {
      margin-bottom: 20px;
    }

    .form-group label {
      display: block;
      margin-bottom: 8px;
      font-weight: 600;
      color: #374151;
    }

    .form-group input {
      width: 100%;
      padding: 12px;
      border: 2px solid #e5e7eb;
      border-radius: 8px;
      font-size: 14px;
      transition: border-color 0.3s;
    }

    .form-group input:focus {
      outline: none;
      border-color: #667eea;
    }

    .button-group {
      display: flex;
      gap: 10px;
      margin-top: 20px;
    }

    button {
      flex: 1;
      padding: 14px 24px;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
    }

    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .btn-primary:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
    }

    .btn-secondary {
      background: #6b7280;
      color: white;
    }

    .btn-danger {
      background: #ef4444;
      color: white;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .log-container {
      background: #f9fafb;
      border: 2px solid #e5e7eb;
      border-radius: 8px;
      padding: 15px;
      max-height: 150px;
      overflow-y: auto;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      margin-top: 20px;
    }

    .log-entry {
      padding: 4px 0;
      border-bottom: 1px solid #e5e7eb;
    }

    .log-entry:last-child {
      border-bottom: none;
    }

    .log-time {
      color: #6b7280;
      margin-right: 8px;
    }

    .log-info { color: #3b82f6; }
    .log-success { color: #10b981; }
    .log-error { color: #ef4444; }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>ğŸ“º è§‚ä¼—è§‚çœ‹æ§åˆ¶å°</h1>
      <p>MicroVibe WebRTC SFU ç›´æ’­ç³»ç»Ÿ - gRPC ä¿¡ä»¤ä¸­ç»§æ¨¡å¼</p>
    </div>

    <div class="content">
      <!-- è§†é¢‘æ’­æ”¾ -->
      <div class="video-container">
        <video id="remoteVideo" autoplay playsinline controls muted></video>
        <div class="video-overlay">
          <div class="status-badge" id="statusBadge">
            <span class="status-dot" id="statusDot"></span>
            <span id="statusText">æœªè¿æ¥</span>
          </div>
          <div class="viewer-count">
            ğŸ‘ï¸ <span id="viewerCount">0</span> äººè§‚çœ‹
          </div>
        </div>
        <div class="stats" id="stats" style="display: none;">
          <div>è§†é¢‘ç ç‡: <span id="videoBitrate">0</span> kbps</div>
          <div>éŸ³é¢‘ç ç‡: <span id="audioBitrate">0</span> kbps</div>
          <div>ä¸¢åŒ…ç‡: <span id="packetLoss">0</span>%</div>
          <div>å»¶è¿Ÿ: <span id="rtt">0</span> ms</div>
        </div>
      </div>

      <!-- ç›´æ’­é—´åˆ—è¡¨ -->
      <div id="roomListSection">
        <h3 style="margin-bottom: 15px; color: #374151;">ğŸ”´ æ­£åœ¨ç›´æ’­</h3>
        <div class="room-list" id="roomList">
          <div style="grid-column: 1/-1; text-align: center; padding: 20px; color: #6b7280;">
            æ­£åœ¨åŠ è½½ç›´æ’­åˆ—è¡¨...
          </div>
        </div>
      </div>

      <!-- æ‰‹åŠ¨è¾“å…¥æˆ¿é—´ID -->
      <div class="form-group">
        <label for="roomId">æˆ–æ‰‹åŠ¨è¾“å…¥æˆ¿é—´ ID</label>
        <input type="text" id="roomId" placeholder="è¾“å…¥æˆ¿é—´ IDï¼ˆä¾‹å¦‚ï¼šroom-123ï¼‰">
      </div>

      <!-- æŒ‰é’®ç»„ -->
      <div class="button-group">
        <button id="joinBtn" class="btn-primary" onclick="joinLive()">ğŸ¬ åŠ å…¥ç›´æ’­</button>
        <button id="leaveBtn" class="btn-danger" onclick="leaveLive()" disabled>ğŸ‘‹ ç¦»å¼€ç›´æ’­</button>
        <button class="btn-secondary" onclick="refreshRoomList()">ğŸ”„ åˆ·æ–°åˆ—è¡¨</button>
      </div>

      <!-- æ—¥å¿— -->
      <div class="log-container" id="logContainer">
        <div class="log-entry">
          <span class="log-time">[ç³»ç»Ÿ]</span>
          <span class="log-info">å‡†å¤‡å°±ç»ªï¼Œé€‰æ‹©ç›´æ’­é—´æˆ–è¾“å…¥æˆ¿é—´ ID...</span>
        </div>
      </div>
    </div>
  </div>

  <script>
    // å…¨å±€å˜é‡
    let peerConnection = null;
    let websocket = null;
    let currentRoomId = null;
    let statsInterval = null;
    const apiUrl = 'http://localhost:8080/api/v1';

    // å›ºå®šçš„è§‚çœ‹è€…ç”¨æˆ·IDï¼ˆç”Ÿäº§ç¯å¢ƒä¸­åº”ä»ç™»å½•çŠ¶æ€è·å–ï¼‰
    const viewerUserId = 2;
    const viewerUsername = 'viewer';

    // æ—¥å¿—å‡½æ•°
    function log(message, type = 'info') {
      const logContainer = document.getElementById('logContainer');
      const time = new Date().toLocaleTimeString();
      const entry = document.createElement('div');
      entry.className = 'log-entry';
      entry.innerHTML = `
        <span class="log-time">[${time}]</span>
        <span class="log-${type}">${message}</span>
      `;
      logContainer.appendChild(entry);
      logContainer.scrollTop = logContainer.scrollHeight;
      console.log(`[${type}] ${message}`);
    }

    // æ›´æ–°çŠ¶æ€
    function updateStatus(text, connected = false) {
      document.getElementById('statusText').textContent = text;
      const statusDot = document.getElementById('statusDot');
      if (connected) {
        statusDot.classList.add('connected');
      } else {
        statusDot.classList.remove('connected');
      }
    }

    // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
    function updateStats(stats) {
      document.getElementById('videoBitrate').textContent = Math.round(stats.videoBitrate / 1000);
      document.getElementById('audioBitrate').textContent = Math.round(stats.audioBitrate / 1000);
      document.getElementById('packetLoss').textContent = (stats.packetLoss * 100).toFixed(2);
      document.getElementById('rtt').textContent = Math.round(stats.rtt * 1000);
    }

    // åŠ è½½ç›´æ’­åˆ—è¡¨
    async function loadRoomList() {
      try {
        const response = await fetch(`${apiUrl}/live/list?status=live&page=1&page_size=20`);
        const data = await response.json();

        const roomList = document.getElementById('roomList');
        if (data.data && data.data.list && data.data.list.length > 0) {
          roomList.innerHTML = data.data.list.map(room => `
            <div class="room-card" onclick="selectRoom('${room.room_id}')">
              <div class="room-title">${room.title}</div>
              <div class="room-info">
                ğŸ‘ï¸ ${room.online_count} è§‚çœ‹ | â¤ï¸ ${room.like_count} ç‚¹èµ
              </div>
              <div class="room-info" style="margin-top: 5px;">
                æˆ¿é—´ ID: ${room.room_id}
              </div>
            </div>
          `).join('');
        } else {
          roomList.innerHTML = '<div style="grid-column: 1/-1; text-align: center; padding: 20px; color: #6b7280;">æš‚æ— ç›´æ’­é—´</div>';
        }

        log(`åŠ è½½äº† ${data.data?.list?.length || 0} ä¸ªç›´æ’­é—´`, 'success');
      } catch (error) {
        log(`åŠ è½½ç›´æ’­åˆ—è¡¨å¤±è´¥: ${error.message}`, 'error');
      }
    }

    // é€‰æ‹©æˆ¿é—´
    function selectRoom(roomId) {
      document.getElementById('roomId').value = roomId;
      document.querySelectorAll('.room-card').forEach(card => {
        card.classList.remove('active');
      });
      event.currentTarget.classList.add('active');
      log(`å·²é€‰æ‹©æˆ¿é—´: ${roomId}`, 'info');
    }

    // åˆ·æ–°æˆ¿é—´åˆ—è¡¨
    function refreshRoomList() {
      log('æ­£åœ¨åˆ·æ–°ç›´æ’­åˆ—è¡¨...', 'info');
      loadRoomList();
    }

    // åŠ å…¥ç›´æ’­
    async function joinLive() {
      try {
        const roomId = document.getElementById('roomId').value;
        if (!roomId) {
          log('âŒ è¯·é€‰æ‹©æˆ–è¾“å…¥æˆ¿é—´ ID', 'error');
          return;
        }

        log(`æ­£åœ¨åŠ å…¥ç›´æ’­é—´: ${roomId}`, 'info');
        document.getElementById('joinBtn').disabled = true;
        currentRoomId = roomId;
        updateStatus('æ­£åœ¨è¿æ¥...', false);

        // 1. è¿æ¥ WebSocket ä¿¡ä»¤æœåŠ¡å™¨
        log('æ­£åœ¨è¿æ¥ä¿¡ä»¤æœåŠ¡å™¨...', 'info');
        const wsUrl = apiUrl.replace('http', 'ws') + `/live/ws?room_id=${roomId}&user_id=${viewerUserId}&username=${viewerUsername}&role=subscriber`;
        websocket = new WebSocket(wsUrl);

        websocket.onopen = () => {
          log('âœ… WebSocket è¿æ¥æˆåŠŸ', 'success');
          setupPeerConnection();
        };

        websocket.onmessage = handleSignalingMessage;

        websocket.onerror = (error) => {
          log(`âŒ WebSocket é”™è¯¯`, 'error');
          updateStatus('è¿æ¥å¤±è´¥', false);
        };

        websocket.onclose = () => {
          log('WebSocket è¿æ¥å…³é—­', 'info');
          updateStatus('è¿æ¥å·²æ–­å¼€', false);
        };

        // 2. è°ƒç”¨åŠ å…¥ç›´æ’­é—´ APIï¼ˆæ›´æ–°åœ¨çº¿äººæ•°ï¼‰
        try {
          await fetch(`${apiUrl}/live/join/${roomId}`, {
            method: 'POST',
          });
          log('âœ… å·²åŠ å…¥ç›´æ’­é—´ï¼ˆä¸šåŠ¡å±‚ï¼‰', 'success');
        } catch (error) {
          log(`åŠ å…¥ç›´æ’­é—´ API å¤±è´¥: ${error.message}`, 'error');
        }

      } catch (error) {
        log(`âŒ åŠ å…¥å¤±è´¥: ${error.message}`, 'error');
        document.getElementById('joinBtn').disabled = false;
        updateStatus('æœªè¿æ¥', false);
      }
    }

    // è®¾ç½® PeerConnectionï¼ˆä½œä¸ºè®¢é˜…è€…ï¼‰
    async function setupPeerConnection() {
      try {
        log('æ­£åœ¨åˆ›å»º PeerConnectionï¼ˆè®¢é˜…è€…æ¨¡å¼ï¼‰...', 'info');

        // åˆ›å»º PeerConnection
        // æœ¬åœ°æµ‹è¯•ä¸éœ€è¦ STUNï¼ŒSFU ä½¿ç”¨ ICE Lite æ¨¡å¼
        peerConnection = new RTCPeerConnection({
          iceServers: []
        });

        // æ·»åŠ  transceiverï¼ˆä½œä¸ºæ¥æ”¶ç«¯ï¼‰
        peerConnection.addTransceiver('audio', { direction: 'recvonly' });
        peerConnection.addTransceiver('video', { direction: 'recvonly' });
        log('å·²æ·»åŠ éŸ³è§†é¢‘ transceiverï¼ˆä»…æ¥æ”¶ï¼‰', 'info');

        // æ¥æ”¶è¿œç¨‹åª’ä½“æµ
        peerConnection.ontrack = (event) => {
          log(`âœ… æ”¶åˆ° ${event.track.kind} è½¨é“`, 'success');
          const remoteVideo = document.getElementById('remoteVideo');
          if (event.streams && event.streams[0]) {
            remoteVideo.srcObject = event.streams[0];
            log('âœ… è§†é¢‘æµå·²ç»‘å®šåˆ°æ’­æ”¾å™¨', 'success');

            // ä¸»åŠ¨è§¦å‘æ’­æ”¾ï¼ˆè§£å†³autoplayè¢«é˜»æ­¢çš„é—®é¢˜ï¼‰
            remoteVideo.play().then(() => {
              log('âœ… è§†é¢‘æ’­æ”¾æˆåŠŸ', 'success');
            }).catch(err => {
              log(`âš ï¸ è‡ªåŠ¨æ’­æ”¾å¤±è´¥ï¼Œè¯·ç‚¹å‡»æ’­æ”¾æŒ‰é’®: ${err.message}`, 'error');
            });
          }
        };

        // ICE Candidate å¤„ç†
        peerConnection.onicecandidate = (event) => {
          if (event.candidate && websocket && websocket.readyState === WebSocket.OPEN) {
            websocket.send(JSON.stringify({
              type: 'ice',
              room_id: currentRoomId,
              payload: event.candidate
            }));
            log('å‘é€ ICE Candidate', 'info');
          }
        };

        // è¿æ¥çŠ¶æ€ç›‘å¬
        peerConnection.onconnectionstatechange = () => {
          const state = peerConnection.connectionState;
          log(`è¿æ¥çŠ¶æ€: ${state}`, 'info');

          if (state === 'connected') {
            updateStatus('ğŸŸ¢ è§‚çœ‹ä¸­', true);
            document.getElementById('stats').style.display = 'block';
            document.getElementById('leaveBtn').disabled = false;
            startStatsCollection();
            log('âœ… WebRTC è¿æ¥å·²å»ºç«‹', 'success');
          } else if (state === 'failed') {
            updateStatus('è¿æ¥å¤±è´¥', false);
            log('âŒ WebRTC è¿æ¥å¤±è´¥', 'error');
          } else if (state === 'disconnected') {
            updateStatus('è¿æ¥æ–­å¼€', false);
            log('âš ï¸ WebRTC è¿æ¥å·²æ–­å¼€', 'error');
          }
        };

        // åˆ›å»º Offerï¼ˆè®¢é˜…è€…ä¸»åŠ¨åˆ›å»º Offerï¼‰
        log('æ­£åœ¨åˆ›å»º SDP Offer...', 'info');
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        log('âœ… æœ¬åœ° Offer å·²è®¾ç½®', 'success');

        // å‘é€ Offer åˆ°æœåŠ¡å™¨ï¼ˆé€šè¿‡ä¿¡ä»¤ä¸­ç»§åˆ° SFUï¼‰
        websocket.send(JSON.stringify({
          type: 'offer',
          room_id: currentRoomId,
          payload: offer.sdp  // åªå‘é€ SDP å­—ç¬¦ä¸²
        }));
        log('âœ… Offer å·²å‘é€åˆ°æœåŠ¡å™¨', 'success');

      } catch (error) {
        log(`âŒ PeerConnection é”™è¯¯: ${error.message}`, 'error');
        updateStatus('åˆ›å»ºè¿æ¥å¤±è´¥', false);
      }
    }

    // å¤„ç†ä¿¡ä»¤æ¶ˆæ¯
    async function handleSignalingMessage(event) {
      try {
        const message = JSON.parse(event.data);

        switch (message.type) {
          case 'answer':
            // æ”¶åˆ° SFU è¿”å›çš„ Answer
            log('æ”¶åˆ° SDP Answer', 'success');

            // æå– SDPï¼ˆå…¼å®¹å­—ç¬¦ä¸²å’Œå¯¹è±¡æ ¼å¼ï¼‰
            let sdp;
            if (typeof message.payload === 'string') {
              sdp = message.payload;
            } else if (message.payload && message.payload.sdp) {
              sdp = message.payload.sdp;
            } else {
              throw new Error('æ— æ•ˆçš„ Answer æ ¼å¼');
            }

            const answer = new RTCSessionDescription({
              type: 'answer',
              sdp: sdp
            });

            await peerConnection.setRemoteDescription(answer);
            log('âœ… Answer å·²è®¾ç½®ä¸ºè¿œç¨‹æè¿°', 'success');
            break;

          case 'ice':
            // æ”¶åˆ° ICE Candidate
            if (message.payload && peerConnection) {
              await peerConnection.addIceCandidate(new RTCIceCandidate(message.payload));
              log('å·²æ·»åŠ  ICE Candidate', 'info');
            }
            break;

          case 'user_joined':
            log(`ç”¨æˆ· ${message.username} åŠ å…¥ç›´æ’­é—´`, 'info');
            break;

          case 'user_left':
            log(`ç”¨æˆ· ${message.username} ç¦»å¼€ç›´æ’­é—´`, 'info');
            break;

          case 'error':
            const errorMsg = message.payload?.error || 'æœªçŸ¥é”™è¯¯';
            log(`âŒ æœåŠ¡å™¨é”™è¯¯: ${errorMsg}`, 'error');
            updateStatus('æœåŠ¡å™¨é”™è¯¯', false);
            break;

          default:
            log(`æ”¶åˆ°æ¶ˆæ¯: ${message.type}`, 'info');
        }
      } catch (error) {
        log(`âŒ å¤„ç†æ¶ˆæ¯å¤±è´¥: ${error.message}`, 'error');
      }
    }

    // å¼€å§‹ç»Ÿè®¡ä¿¡æ¯æ”¶é›†
    function startStatsCollection() {
      if (statsInterval) clearInterval(statsInterval);

      statsInterval = setInterval(async () => {
        if (!peerConnection) return;

        try {
          const stats = await peerConnection.getStats();
          let videoBitrate = 0;
          let audioBitrate = 0;
          let packetLoss = 0;
          let rtt = 0;

          stats.forEach(report => {
            if (report.type === 'inbound-rtp') {
              if (report.kind === 'video' && report.bytesReceived) {
                videoBitrate = (report.bytesReceived * 8) / (report.timestamp / 1000);
              } else if (report.kind === 'audio' && report.bytesReceived) {
                audioBitrate = (report.bytesReceived * 8) / (report.timestamp / 1000);
              }
            }
            if (report.type === 'candidate-pair' && report.state === 'succeeded') {
              rtt = report.currentRoundTripTime || 0;
              if (report.packetsReceived > 0) {
                packetLoss = (report.packetsLost || 0) / report.packetsReceived;
              }
            }
          });

          updateStats({ videoBitrate, audioBitrate, packetLoss, rtt });
        } catch (error) {
          console.error('ç»Ÿè®¡ä¿¡æ¯æ”¶é›†å¤±è´¥:', error);
        }
      }, 2000);
    }

    // ç¦»å¼€ç›´æ’­
    async function leaveLive() {
      log('æ­£åœ¨ç¦»å¼€ç›´æ’­é—´...', 'info');

      // åœæ­¢ç»Ÿè®¡
      if (statsInterval) {
        clearInterval(statsInterval);
        statsInterval = null;
      }

      // å…³é—­ PeerConnection
      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
        log('PeerConnection å·²å…³é—­', 'info');
      }

      // å…³é—­ WebSocket
      if (websocket) {
        if (websocket.readyState === WebSocket.OPEN) {
          websocket.send(JSON.stringify({
            type: 'leave',
            room_id: currentRoomId
          }));
        }
        websocket.close();
        websocket = null;
        log('WebSocket å·²å…³é—­', 'info');
      }

      // åœæ­¢è§†é¢‘
      const remoteVideo = document.getElementById('remoteVideo');
      remoteVideo.srcObject = null;

      // è°ƒç”¨ç¦»å¼€ API
      if (currentRoomId) {
        try {
          await fetch(`${apiUrl}/live/leave/${currentRoomId}`, {
            method: 'POST',
          });
          log('âœ… å·²ç¦»å¼€ç›´æ’­é—´ï¼ˆä¸šåŠ¡å±‚ï¼‰', 'success');
        } catch (error) {
          log(`ç¦»å¼€ç›´æ’­é—´ API å¤±è´¥: ${error.message}`, 'error');
        }
      }

      // é‡ç½®çŠ¶æ€
      updateStatus('æœªè¿æ¥', false);
      document.getElementById('stats').style.display = 'none';
      document.getElementById('joinBtn').disabled = false;
      document.getElementById('leaveBtn').disabled = true;
      currentRoomId = null;

      log('âœ… å·²é€€å‡ºè§‚çœ‹', 'success');
    }

    // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
    window.addEventListener('load', () => {
      log('é¡µé¢åŠ è½½å®Œæˆ', 'info');
      loadRoomList();

      // æ¯10ç§’åˆ·æ–°ä¸€æ¬¡åˆ—è¡¨ï¼ˆä»…åœ¨æœªè§‚çœ‹æ—¶ï¼‰
      setInterval(() => {
        if (!currentRoomId) {
          loadRoomList();
        }
      }, 10000);
    });

    // é¡µé¢å…³é—­æ—¶æ¸…ç†
    window.addEventListener('beforeunload', () => {
      if (currentRoomId) {
        leaveLive();
      }
    });
  </script>
</body>
</html>
