# 推荐算法架构

## 概述

MicroVibe-Go 实现了一套完整的短视频推荐算法系统，采用经典的"召回-排序-过滤"三层架构，能够为用户提供个性化的视频推荐。

## 算法架构

```
用户请求
    ↓
┌─────────────┐
│  召回层     │  从海量视频中快速召回候选集（1000+）
└─────────────┘
    ↓
┌─────────────┐
│ 特征工程    │  提取用户和视频特征
└─────────────┘
    ↓
┌─────────────┐
│  排序层     │  精准排序候选视频（100+）
└─────────────┘
    ↓
┌─────────────┐
│  过滤层     │  过滤和去重（20+）
└─────────────┘
    ↓
推荐结果
```

## 一、召回层

召回层的目标是从海量视频中快速筛选出用户可能感兴趣的候选集。采用多路召回策略，提高召回的覆盖率和准确率。

### 1.1 协同过滤召回

基于"和你相似的用户也喜欢"的思想：

```
算法步骤：
1. 获取用户最近喜欢的视频（TopN）
2. 找到也喜欢这些视频的相似用户
3. 推荐这些相似用户喜欢的其他视频
```

**代码实现**：`internal/algorithm/recommend/recall.go::collaborativeFilteringRecall`

### 1.2 内容召回

基于用户的兴趣标签推荐相关内容：

```
算法步骤：
1. 获取用户的兴趣标签（分类、话题）
2. 根据兴趣标签的权重，召回对应分类的热门视频
3. 按照兴趣分数和视频热度排序
```

**代码实现**：`internal/algorithm/recommend/recall.go::contentBasedRecall`

### 1.3 热门召回

保证用户能看到热门内容：

```
算法步骤：
1. 从 Redis 缓存获取24小时内的热门视频
2. 如果缓存未命中，从数据库查询并更新缓存
3. 按照热度分数排序
```

**代码实现**：`internal/algorithm/recommend/recall.go::hotRecall`

### 1.4 关注召回

推荐关注用户发布的视频：

```
算法步骤：
1. 获取用户关注的人
2. 获取这些人最近发布的视频
3. 按时间倒序排序
```

**代码实现**：`internal/algorithm/recommend/recall.go::followRecall`

### 1.5 新视频召回（冷启动）

给新视频曝光机会：

```
算法步骤：
1. 召回1小时内新发布的视频
2. 给予一定的流量支持
3. 根据初期表现调整后续推荐策略
```

**代码实现**：`internal/algorithm/recommend/recall.go::newVideoRecall`

## 二、特征工程

特征工程负责提取和计算用户特征、视频特征，为排序算法提供依据。

### 2.1 用户特征

```go
type UserFeature struct {
    // 基础特征
    Age, Gender, Province, City

    // 行为特征
    ActiveDays        // 活跃天数
    AvgWatchTime      // 平均观看时长
    AvgFinishRate     // 平均完播率
    LikeRate          // 点赞率
    CommentRate       // 评论率
    ShareRate         // 分享率

    // 兴趣标签
    InterestTags      // map[CategoryID]Score

    // 时间偏好
    ActiveHours       // 活跃时段
}
```

**特征计算**：
- 从用户最近30天的行为数据中统计
- 使用 Redis 缓存，1小时过期
- 支持实时更新

**代码实现**：`internal/algorithm/feature/engineer.go`

### 2.2 视频特征

```go
type VideoFeature struct {
    // 内容特征
    CategoryID, Duration, Tags

    // 质量特征
    QualityScore      // 质量分（0-100）
    FinishRate        // 完播率
    AvgWatchTime      // 平均观看时长

    // 互动特征
    CTR               // 点击率
    LikeRate          // 点赞率
    CommentRate       // 评论率
    ShareRate         // 分享率

    // 热度特征
    HotScore          // 热度分数
    TrendScore        // 趋势分数

    // 新鲜度
    FreshnessScore    // 新鲜度分数（时间衰减）
}
```

**特征计算**：
- 从视频统计数据中计算
- 使用 Redis 缓存，30分钟过期
- 定时任务更新统计数据

## 三、排序层

排序层使用多目标融合的方式，对候选视频进行精准排序。

### 3.1 综合评分公式

```
总分 = CTR预估 × 0.3
     + 完播率预估 × 0.25
     + 互动率预估 × 0.25
     + 热度分 × 0.1
     + 新鲜度分 × 0.1
```

**代码实现**：`internal/algorithm/rank/ranker.go::calculateScore`

### 3.2 CTR 预估（点击率）

```go
CTR预估 = 基础分(0.5)
        + 视频质量分 × 0.2
        + 历史CTR × 0.3
        + 兴趣匹配度 × 0.5
```

**兴趣匹配度**：
- 如果视频分类在用户兴趣标签中，使用对应的兴趣分数
- 否则为0

### 3.3 完播率预估

```go
完播率预估 = 基础分(0.5)
          + 时长因素 × 0.3    // 视频越短，完播率越高
          + 历史完播率 × 0.4
          + 用户平均完播率 × 0.3
```

### 3.4 互动率预估

```go
互动率 = 点赞率 × 0.4
       + 评论率 × 0.3
       + 分享率 × 0.3
```

### 3.5 新鲜度计算

使用指数衰减函数：

```go
新鲜度 = e^(-0.693 × 小时数 / 24)
```

半衰期设为24小时，即24小时后新鲜度降至50%。

### 3.6 多样性策略

为避免信息茧房，限制同一分类的视频数量：

```go
func ApplyDiversity(videos []Video, ratio float64) []Video {
    // 同一分类最多3个视频
    // 超过则跳过
}
```

## 四、过滤层

过滤层负责最后的质量把关和去重。

### 4.1 已看过滤

```
- 从 Redis 获取用户7天内观看的视频ID
- 过滤掉已观看的视频
- 避免重复推荐
```

### 4.2 质量过滤

```go
// 过滤条件
- 质量分 < 30
- 状态不是已发布
- 时长异常（< 3秒 或 > 1小时）
```

### 4.3 相似视频去重

```
- 同一分类的视频不超过2个
- 保证推荐结果的多样性
```

### 4.4 黑名单过滤

```
- 过滤用户拉黑的作者的视频
- 从 Redis 缓存中快速检查
```

**代码实现**：`internal/algorithm/filter/filter.go`

## 五、性能优化

### 5.1 缓存策略

| 数据类型 | 缓存时间 | 存储方式 |
|---------|---------|---------|
| 热门视频 | 1小时 | Redis Sorted Set |
| 用户特征 | 1小时 | Redis String (JSON) |
| 视频特征 | 30分钟 | Redis String (JSON) |
| 已观看视频 | 7天 | Redis Set |
| 黑名单 | 永久 | Redis Set |

### 5.2 数据库优化

```sql
-- 关键索引
CREATE INDEX idx_video_category_hot ON videos(category_id, hot_score DESC);
CREATE INDEX idx_video_status_time ON videos(status, published_at DESC);
CREATE INDEX idx_behavior_user_time ON user_behaviors(user_id, created_at);
CREATE INDEX idx_like_user_video ON likes(user_id, video_id);
```

### 5.3 召回数量控制

```
召回阶段：1000+ 视频
排序阶段：100+ 视频
最终返回：20 视频
```

通过漏斗式过滤，在保证质量的同时提高性能。

## 六、算法评估

### 6.1 离线评估指标

- **召回率**：召回的视频中有多少是用户真正感兴趣的
- **准确率**：推荐的视频中有多少被用户点击
- **覆盖率**：能推荐到多少比例的视频

### 6.2 在线评估指标

- **CTR**：点击率
- **完播率**：视频播放完成率
- **互动率**：点赞、评论、分享率
- **人均观看时长**：用户平均观看时长
- **留存率**：用户次日/7日留存

### 6.3 A/B 测试

```
- 对照组：原算法
- 实验组：新算法
- 流量分配：50% vs 50%
- 观察周期：7天
- 决策指标：CTR、完播率、留存率
```

## 七、未来优化方向

### 7.1 深度学习模型

- **Wide & Deep**：结合记忆和泛化能力
- **DeepFM**：自动特征交叉
- **DIN**：用户兴趣动态建模
- **DSSM**：双塔模型，提升召回效率

### 7.2 实时计算

- **Flink**：实时特征计算
- **Kafka**：行为数据流处理
- **实时模型更新**：分钟级模型迭代

### 7.3 多目标优化

- **时长优化**：不仅关注点击，还关注观看时长
- **新作者扶持**：给新作者更多曝光机会
- **内容安全**：过滤低俗、违规内容

### 7.4 个性化增强

- **用户画像细化**：更精准的兴趣建模
- **场景感知**：根据时间、地点调整推荐
- **社交关系**：利用好友关系增强推荐

## 八、参考资料

- [YouTube 推荐算法论文](https://research.google/pubs/pub45530/)
- [抖音推荐算法解析](https://mp.weixin.qq.com/s/...)
- [推荐系统实践](https://book.douban.com/subject/10769749/)
